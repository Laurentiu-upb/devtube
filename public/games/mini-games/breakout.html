<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Breakout+ – HTML5 Canvas</title>
<style>
  :root { --bg:#0b0f15; --panel:#121826; --text:#e7ecf3; --muted:#9fb0c8; --accent:#3ea6ff; }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;background:radial-gradient(1200px 800px at 70% -10%,#152033 0%,var(--bg) 60%);color:var(--text);display:grid;place-items:center}
  .wrap{display:grid;grid-template-columns:auto 280px;gap:18px;align-items:start;padding:16px}
  .panel{background:linear-gradient(180deg,#0f1524 0%,var(--panel) 100%);border:1px solid #1e2a44;border-radius:16px;padding:14px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  h1{margin:0 0 8px;font-size:18px;font-weight:700;letter-spacing:.5px;color:var(--text)}
  .stats{display:grid;grid-template-columns:1fr 1fr;gap:8px 12px;font-weight:600;margin-bottom:8px}
  .stats div:nth-child(odd){color:var(--muted);font-weight:500}
  .btnrow{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0 0}
  button{cursor:pointer;background:var(--accent);color:#09121f;font-weight:800;border:0;padding:10px 12px;border-radius:12px;box-shadow:0 6px 16px rgba(62,166,255,.35)}
  button.secondary{background:#24324d;color:var(--text);box-shadow:none;border:1px solid #2d3d61}
  #board{background:#0c1220;border:2px solid #213357;border-radius:10px;image-rendering:pixelated;display:block;margin:auto}
  .legend,.diag{font-size:12px;color:var(--muted);line-height:1.35}
  details.diag{background:#0c1220;border:1px solid #1e2a44;border-radius:12px;padding:10px}
  .pass{color:#83e07c}.fail{color:#ff8a8a}
</style>
</head>
<body>
<div class="wrap">
  <!-- Bigger canvas -->
  <canvas id="board" width="720" height="540" class="panel" aria-label="Breakout game area" role="img"></canvas>
  <div class="aside">
    <div class="panel">
      <h1>Breakout+</h1>
      <div class="stats">
        <div>Score</div><div id="score">0</div>
        <div>Lives</div><div id="lives">4</div>
        <div>Level</div><div id="level">1</div>
        <div>Balls</div><div id="balls">1</div>
      </div>
      <div class="btnrow">
        <button id="btnStart">Start / Restart (R)</button>
        <button id="btnPause" class="secondary">Pause (P)</button>
      </div>
    </div>
    <div class="panel legend">
      <div><strong>Controls</strong></div>
      <div>← / → or A / D to move (mouse also works)</div>
      <div>Click or Space to <em>launch</em> the ball when it rests on the paddle</div>
      <div>P pause, R restart</div>
      <div>Power-ups: ➕ Life, ⌛ Slow, ⤢ Expand</div>
    </div>
    <details class="diag" id="diagBox">
      <summary>Diagnostics & tests</summary>
      <div id="diag"></div>
      <div style="margin-top:8px"><button id="btnTests" class="secondary">Run tests again</button></div>
    </details>
  </div>
</div>
<script>
(() => {
  // ===== Canvas & UI =====
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const elScore = document.getElementById('score');
  const elLives = document.getElementById('lives');
  const elLevel = document.getElementById('level');
  const elBalls = document.getElementById('balls');
  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');
  const btnTests = document.getElementById('btnTests');
  const diag = document.getElementById('diag');
  const diagBox = document.getElementById('diagBox');

  // ===== Gameplay config =====
  const COLORS = { one:'#3ea6ff', two:'#ff9f3a', three:'#ff6f6f', steel:'#9fb0c8', ball:'#ffd53a', paddle:'#61e294'};
  const POWER_COLORS = { life:'#6be36b', slow:'#b7a6ff', expand:'#ffd53a' };
  const BRICK_TYPES = {
    '.': null,                                 // empty
    '1': { hp:1, color:COLORS.one,   score:50 },
    '2': { hp:2, color:COLORS.two,   score:80 },
    '3': { hp:3, color:COLORS.three, score:120 },
    '#': { hp:9999, color:COLORS.steel, score:0 } // unbreakable
  };
  // Level layouts
  const LEVELS = [
    [
      '..............',
      '..1111111111..',
      '..1222333221..',
      '..122###3221..',
      '..1111111111..',
      '..............'
    ],
    [
      '..222..333..222..',
      '..2##2.3..3.2##2.',
      '..222..333..222..',
      '....111....111....',
      '....1..1....1..1..'
    ],
    [
      '3333333333333333',
      '3..22222##2222..3',
      '3..21111221112..3',
      '3..2##22..22##2..3',
      '3..21111221112..3',
      '3333333333333333'
    ]
  ];

  // World sizing derived from level width
  let GRID_COLS = 0, GRID_ROWS = 0, BRICK_W = 0, BRICK_H = 28, BRICK_PAD = 6, BRICK_TOP = 60, BRICK_LEFT = 0;

  // Paddle & balls
  let paddleW = 120, paddleH = 14, paddleX = 0, paddleSpeed = 7;
  let balls = []; // each: {x,y,dx,dy,r}
  const BALL_R = 9; // bigger
  const BASE_SPEED = 1.8; // much slower baseline
  const MAX_SPEED = 3.6;  // cap
  let ballOnPaddle = true; // launch mechanic

  // Power-ups
  let powerUps = []; // {x,y,vy,type}
  const POWER_CHANCE = 0.12; // 12% drop chance per brick

  // Game state
  let bricks = []; // 2D array of {x,y,hp,color,score,solid}
  let level = 1, score = 0, lives = 4, paused = false, over = false, pressing = {left:false,right:false};

  // ===== Utility =====
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  function setLevel(n){
    const layout = LEVELS[(n-1) % LEVELS.length];
    GRID_ROWS = layout.length;
    GRID_COLS = layout[0].length;
    BRICK_W = Math.floor((canvas.width - 2*24 - (GRID_COLS-1)*BRICK_PAD) / GRID_COLS);
    BRICK_LEFT = Math.floor((canvas.width - (GRID_COLS*BRICK_W + (GRID_COLS-1)*BRICK_PAD))/2);
    bricks = [];
    for (let r=0;r<GRID_ROWS;r++){
      bricks[r] = [];
      for (let c=0;c<GRID_COLS;c++){
        const key = layout[r][c];
        const def = BRICK_TYPES[key];
        if (!def){ bricks[r][c] = null; continue; }
        bricks[r][c] = {
          x: BRICK_LEFT + c*(BRICK_W+BRICK_PAD),
          y: BRICK_TOP + r*(BRICK_H+BRICK_PAD),
          hp: def.hp,
          color: def.color,
          score: def.score,
          solid: key==='#'
        };
      }
    }
  }

  function resetPaddle(){ paddleW = 120; paddleX = (canvas.width - paddleW)/2; }

  function addBall(opts={}){
    const b = {
      x: opts.x ?? canvas.width/2,
      y: opts.y ?? (canvas.height - 80),
      dx: (opts.dx ?? 0),  // 0 when on paddle
      dy: (opts.dy ?? 0),
      r: BALL_R
    };
    balls.push(b);
    updateUI();
  }

  function resetGame(){
    level = 1; score = 0; lives = 4; over = false; paused = false; powerUps = []; balls = []; ballOnPaddle = true;
    setLevel(level);
    resetPaddle();
    // start with one ball sitting on paddle
    addBall({ x: paddleX + paddleW/2, y: canvas.height - 20 - paddleH - BALL_R - 1, dx:0, dy:0 });
    updateUI();
  }

  function updateUI(){ elScore.textContent = score; elLives.textContent = lives; elLevel.textContent = level; elBalls.textContent = balls.length; }

  // ===== Input =====
  document.addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if (k==='arrowright' || k==='d') pressing.right = true;
    else if (k==='arrowleft' || k==='a') pressing.left = true;
    else if (k==='p') paused = !paused;
    else if (k==='r') { resetGame(); }
    else if (k===' ') { tryLaunch(); }
  });
  document.addEventListener('keyup', (e)=>{
    const k = e.key.toLowerCase();
    if (k==='arrowright' || k==='d') pressing.right = false;
    else if (k==='arrowleft' || k==='a') pressing.left = false;
  });
  canvas.addEventListener('mousemove', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width/rect.width);
    paddleX = clamp(mx - paddleW/2, 0, canvas.width - paddleW);
    if (ballOnPaddle && balls[0]) {
      balls[0].x = paddleX + paddleW/2;
      balls[0].y = canvas.height - 20 - paddleH - BALL_R - 1;
    }
  });
  canvas.addEventListener('click', ()=>{ tryLaunch(); });

  // Buttons
  btnStart.addEventListener('click', ()=>{ resetGame(); });
  btnPause.addEventListener('click', ()=>{ paused = !paused; });

  function tryLaunch(){
    if (!ballOnPaddle || !balls[0]) return;
    const b = balls[0];
    // aim slightly depending on current paddle movement
    const bias = (pressing.right? 0.4 : 0) + (pressing.left? -0.4 : 0);
    const angle = (-Math.PI/3) + (Math.PI/6) + bias; // gentle upward
    b.dx = Math.sin(angle) * BASE_SPEED;
    b.dy = -Math.abs(Math.cos(angle) * BASE_SPEED);
    ballOnPaddle = false;
  }

  // ===== Mechanics =====
  function step(){
    if (paused || over) return;
    // paddle control
    if (pressing.right) paddleX = Math.min(canvas.width - paddleW, paddleX + 7);
    if (pressing.left) paddleX = Math.max(0, paddleX - 7);

    // keep ball attached if waiting launch
    if (ballOnPaddle && balls[0]){
      balls[0].x = paddleX + paddleW/2;
      balls[0].y = canvas.height - 20 - paddleH - BALL_R - 1;
      return; // no physics until launched
    }

    // move balls
    for (const b of balls){
      b.x += b.dx; b.y += b.dy;
      // walls
      if (b.x < b.r){ b.x = b.r; b.dx = Math.abs(b.dx); }
      if (b.x > canvas.width - b.r){ b.x = canvas.width - b.r; b.dx = -Math.abs(b.dx); }
      if (b.y < b.r){ b.y = b.r; b.dy = Math.abs(b.dy); }

      // paddle collision
      const py = canvas.height - 20 - paddleH; // a bit above bottom
      if (b.y + b.r >= py && b.y + b.r <= py + paddleH + 6 && b.x >= paddleX && b.x <= paddleX + paddleW && b.dy > 0){
        // reflect with angle based on hit position
        const hit = (b.x - (paddleX + paddleW/2)) / (paddleW/2); // -1..1
        const speed = Math.min(MAX_SPEED, Math.hypot(b.dx, b.dy) * 1.03); // very small accel
        const angle = hit * (Math.PI/3); // up to 60°
        b.dx = speed * Math.sin(angle);
        b.dy = -Math.abs(speed * Math.cos(angle));
      }
    }

    // brick collisions
    for (let r=0;r<GRID_ROWS;r++){
      for (let c=0;c<GRID_COLS;c++){
        const br = bricks[r][c]; if (!br) continue; if (br.hp<=0) continue;
        for (const b of balls){
          if (b.x + b.r < br.x || b.x - b.r > br.x + BRICK_W || b.y + b.r < br.y || b.y - b.r > br.y + BRICK_H) continue;
          // compute overlap to choose axis to reflect
          const overlapX = (br.x + BRICK_W/2) - b.x; // center diff
          const overlapY = (br.y + BRICK_H/2) - b.y;
          if (Math.abs(overlapX/BRICK_W) > Math.abs(overlapY/BRICK_H)) b.dx = (overlapX>0? -Math.abs(b.dx): Math.abs(b.dx));
          else b.dy = (overlapY>0? -Math.abs(b.dy): Math.abs(b.dy));
          if (!br.solid){
            br.hp -= 1; score += br.score; if (br.hp===0){ maybeDrop(br.x + BRICK_W/2, br.y + BRICK_H/2); }
          }
        }
      }
    }

    // next level when cleared
    if (allCleared()) nextLevel();

    // power-ups fall
    for (const p of powerUps){ p.y += p.vy; }
    // collect or miss
    powerUps = powerUps.filter(p => {
      const py = canvas.height - 20 - paddleH;
      const caught = p.y > py && p.y < py + paddleH && p.x >= paddleX && p.x <= paddleX + paddleW;
      if (caught){ applyPower(p.type); return false; }
      return p.y < canvas.height + 30; // drop off screen otherwise
    });

    // balls falling below
    balls = balls.filter(b => b.y - b.r <= canvas.height);
    if (balls.length === 0){
      lives--; updateUI();
      if (lives < 0){ over = true; paused = true; }
      else {
        // respawn single ball on paddle waiting for launch
        balls = []; ballOnPaddle = true; addBall({ x: paddleX + paddleW/2, y: canvas.height - 20 - paddleH - BALL_R - 1, dx:0, dy:0 });
      }
    }
  }

  function maybeDrop(x,y){ if (Math.random() < POWER_CHANCE){ const types=['life','slow','expand']; const type = types[Math.floor(Math.random()*types.length)]; powerUps.push({x,y,vy:1.6,type}); } }

  function applyPower(type){
    if (type==='life'){ lives += 1; }
    else if (type==='slow'){ for (const b of balls){ b.dx *= 0.7; b.dy *= 0.7; } }
    else if (type==='expand'){ paddleW = Math.min(paddleW + 30, 220); }
    updateUI();
  }

  function allCleared(){
    for (let r=0;r<GRID_ROWS;r++) for (let c=0;c<GRID_COLS;c++){ const br = bricks[r][c]; if (br && !br.solid && br.hp>0) return false; }
    return true;
  }

  function nextLevel(){ level++; setLevel(level); resetPaddle(); // keep current balls/power-ups
    // keep speeds gentle
    for (const b of balls){ const s = Math.min(MAX_SPEED, Math.hypot(b.dx,b.dy) * 1.05); const ang = Math.atan2(b.dy, b.dx); b.dx = Math.cos(ang)*s; b.dy = Math.sin(ang)*s; }
    updateUI();
  }

  // ===== Rendering =====
  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // bricks
    for (let r=0;r<GRID_ROWS;r++){
      for (let c=0;c<GRID_COLS;c++){
        const br = bricks[r][c]; if (!br || br.hp<=0) continue;
        ctx.fillStyle = br.color; ctx.fillRect(br.x, br.y, BRICK_W, BRICK_H);
        if (!br.solid && br.hp>1){ // draw hp pips
          ctx.fillStyle = 'rgba(0,0,0,0.25)';
          for (let i=0;i<br.hp;i++){ ctx.fillRect(br.x + 6 + i*10, br.y + BRICK_H-6, 8, 4); }
        }
      }
    }

    // paddle
    const py = canvas.height - 20 - paddleH;
    ctx.fillStyle = COLORS.paddle; ctx.fillRect(paddleX, py, paddleW, paddleH);

    // balls
    for (const b of balls){ ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fillStyle = COLORS.ball; ctx.fill(); ctx.closePath(); }

    // power-ups
    for (const p of powerUps){
      ctx.beginPath(); ctx.arc(p.x, p.y, 10, 0, Math.PI*2);
      ctx.fillStyle = POWER_COLORS[p.type]; ctx.fill(); ctx.closePath();
      ctx.fillStyle = '#0c1220'; ctx.font = 'bold 12px system-ui'; ctx.textAlign = 'center'; ctx.fillText(p.type==='life'?'➕':(p.type==='slow'?'⌛':'⤢'), p.x, p.y+4);
    }

    // Launch prompt
    if (ballOnPaddle){
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(0, py-40, canvas.width, 28);
      ctx.fillStyle = '#cfe0ff'; ctx.font = 'bold 16px system-ui'; ctx.textAlign = 'center';
      ctx.fillText('Press Space or Click to Launch', canvas.width/2, py-20);
    }

    if (paused){
      ctx.fillStyle = 'rgba(0,0,0,0.45)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#cfe0ff'; ctx.font = 'bold 28px system-ui'; ctx.textAlign = 'center';
      ctx.fillText(over ? 'Game Over' : 'Paused', canvas.width/2, canvas.height/2 - 10);
      if (over) ctx.fillText('Press R to restart', canvas.width/2, canvas.height/2 + 24);
    }
  }

  // ===== Game loop =====
  let last=0; function loop(ts){ if (!last) last = ts; const dt = ts - last; last = ts; if (!paused) step(); draw(); requestAnimationFrame(loop); }

  // ===== Diagnostics (tests) =====
  function log(t, ok){ const el = document.createElement('div'); el.innerHTML = (ok? '✅ <span class="pass">PASS</span> ' : '❌ <span class="fail">FAIL</span> ') + t; diag?.appendChild(el); (ok?console.log:console.error)(t); }
  function clearDiag(){ if (diag) diag.innerHTML=''; }
  function runTests(){
    clearDiag();
    // 1) Level parser consistency
    setLevel(1); log('Level grid aligns (cols>0 & rows>0)', GRID_COLS>0 && GRID_ROWS>0);
    // 2) Launch waits on paddle
    resetGame(); log('Ball initially on paddle', ballOnPaddle === true && balls.length===1 && balls[0].dy===0);
    // 3) Launch sets upward velocity and below cap
    tryLaunch(); const s = Math.hypot(balls[0].dx, balls[0].dy); log('Launch gives slow upward velocity', s>0 && s<=MAX_SPEED && balls[0].dy<0);
    // 4) Power-up chance valid
    log('Power-up chance valid', POWER_CHANCE>0 && POWER_CHANCE<1);
  }
  btnTests?.addEventListener('click', runTests);

  // ===== Boot =====
  resetGame();
  runTests(); if (diagBox && diag.textContent.includes('FAIL')) diagBox.open = true;
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
