<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pong+ – Tunable Speed & Smarter AI</title>
<style>
  :root { --bg:#0b0f15; --panel:#121826; --text:#e7ecf3; --muted:#9fb0c8; --accent:#3ea6ff; }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;background:radial-gradient(1200px 800px at 70% -10%,#152033 0%,var(--bg) 60%);color:var(--text);display:grid;place-items:center}
  .wrap{display:grid;grid-template-columns:auto 300px;gap:18px;align-items:start;padding:16px}
  .panel{background:linear-gradient(180deg,#0f1524 0%,var(--panel) 100%);border:1px solid #1e2a44;border-radius:16px;padding:14px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  h1{margin:0 0 8px;font-size:18px;font-weight:700;letter-spacing:.5px;color:var(--text)}
  .stats{display:grid;grid-template-columns:1fr 1fr;gap:8px 12px;font-weight:600;margin-bottom:8px}
  .stats div:nth-child(odd){color:var(--muted);font-weight:500}
  .btnrow{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0 0}
  button{cursor:pointer;background:var(--accent);color:#09121f;font-weight:800;border:0;padding:10px 12px;border-radius:12px;box-shadow:0 6px 16px rgba(62,166,255,.35)}
  button.secondary{background:#24324d;color:var(--text);box-shadow:none;border:1px solid #2d3d61}
  #board{background:#0c1220;border:2px solid #213357;border-radius:10px;image-rendering:pixelated;display:block;margin:auto}
  .legend,.diag{font-size:12px;color:var(--muted);line-height:1.35}
  details.diag{background:#0c1220;border:1px solid #1e2a44;border-radius:12px;padding:10px}
  .pass{color:#83e07c}.fail{color:#ff8a8a}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:6px}
  select, input[type="number"], input[type="range"]{background:#0f1524;color:var(--text);border:1px solid #2d3d61;border-radius:10px;padding:6px 8px}
  label{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="board" width="720" height="480" class="panel" aria-label="Pong game area" role="img"></canvas>
  <div class="aside">
    <div class="panel">
      <h1>Pong+</h1>
      <div class="stats">
        <div>Left</div><div id="scoreL">0</div>
        <div>Right</div><div id="scoreR">0</div>
        <div>To Win</div><div><input id="winScore" type="number" min="3" max="21" value="7" style="width:72px"></div>
        <div>Mode</div>
        <div class="row">
          <select id="mode">
            <option value="solo" selected>1P vs AI</option>
            <option value="duo">2 Players</option>
          </select>
          <select id="ai">
            <option value="easy">AI: Easy</option>
            <option value="normal" selected>AI: Normal</option>
            <option value="hard">AI: Hard</option>
          </select>
        </div>
        <div class="row">
          <label for="padSpeed">Paddle speed</label>
          <input id="padSpeed" type="range" min="1" max="200" value="200" />
          <span id="padSpeedVal">200%</span>
        </div>
        <div class="row">
          <label for="ballSpeed">Ball speed</label>
          <input id="ballSpeed" type="range" min="50" max="200" value="100" />
          <span id="ballSpeedVal">100%</span>
        </div>
      </div>
      <div class="btnrow">
        <button id="btnStart">Start / Restart (R)</button>
        <button id="btnPause" class="secondary">Pause (P)</button>
      </div>
    </div>
    <div class="panel legend">
      <div><strong>Controls</strong></div>
      <div>Left paddle: W / S</div>
      <div>Right paddle: ↑ / ↓ (or AI in 1P)</div>
      <div>Space or Click to serve</div>
      <div>P pause, R restart</div>
    </div>
    <details class="diag" id="diagBox">
      <summary>Diagnostics & tests</summary>
      <div id="diag"></div>
      <div style="margin-top:8px"><button id="btnTests" class="secondary">Run tests again</button></div>
    </details>
  </div>
</div>
<script>
(() => {
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const scoreL = document.getElementById('scoreL');
  const scoreR = document.getElementById('scoreR');
  const winScore = document.getElementById('winScore');
  const selMode = document.getElementById('mode');
  const selAI = document.getElementById('ai');
  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');
  const btnTests = document.getElementById('btnTests');
  const diag = document.getElementById('diag');
  const diagBox = document.getElementById('diagBox');
  const padSpeedSlider = document.getElementById('padSpeed');
  const padSpeedVal = document.getElementById('padSpeedVal');
  const ballSpeedSlider = document.getElementById('ballSpeed');
  const ballSpeedVal = document.getElementById('ballSpeedVal');

  const COLORS = { ball:'#ffd53a', paddle:'#61e294', mid:'#213357' };
  const PADDLE_W = 14, PADDLE_H = 100;
  const PADDLE_MARGIN = 28;
  const BALL_R = 8;

  const PAD_MAX_V_BASE = 3.6;
  const PAD_ACCEL_BASE = 0.55;
  const PAD_FRICTION = 0.86;

  const BALL_BASE_SPEED = 2.0;
  const BALL_MAX_SPEED_BASE = 4.2;

  let padSpeedScale = 2.0;
  let ballSpeedScale = 1.0;

  let left = { y: canvas.height/2 - PADDLE_H/2, vy:0, up:false, down:false };
  let right = { y: canvas.height/2 - PADDLE_H/2, vy:0, up:false, down:false };
  let ball = { x: canvas.width/2, y: canvas.height/2, dx:0, dy:0, r: BALL_R };
  let sL = 0, sR = 0, paused=false, over=false, awaitingServe=true;
  let mode = 'solo';
  let aiLevel = 'normal';

  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

  function resetPositions(){
    left.y = canvas.height/2 - PADDLE_H/2; left.vy = 0;
    right.y = canvas.height/2 - PADDLE_H/2; right.vy = 0;
    ball.x = canvas.width/2; ball.y = canvas.height/2; ball.dx = 0; ball.dy = 0; awaitingServe = true;
  }

  function serve(direction = (Math.random()<0.5? -1: 1)){
    const angle = (Math.random()*0.4 - 0.2);
    const speed = BALL_BASE_SPEED * ballSpeedScale;
    ball.dx = Math.cos(angle) * speed * direction;
    ball.dy = Math.sin(angle) * speed;
    awaitingServe = false;
  }

  function updateUI(){ scoreL.textContent = sL; scoreR.textContent = sR; }

  function start(){ sL=0; sR=0; paused=false; over=false; updateUI(); resetPositions(); }

  document.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    if (k==='w') left.up = true; if (k==='s') left.down = true;
    if (k==='arrowup') right.up = true; if (k==='arrowdown') right.down = true;
    if (k==='p') paused = !paused;
    if (k==='r') start();
    if (k===' ') { if (awaitingServe) serve(); }
  });

  document.addEventListener('keyup', e => {
    const k = e.key.toLowerCase();
    if (k==='w') left.up = false; if (k==='s') left.down = false;
    if (k==='arrowup') right.up = false; if (k==='arrowdown') right.down = false;
  });

  canvas.addEventListener('click', () => { if (awaitingServe) serve(); });

  btnStart.addEventListener('click', start);
  btnPause.addEventListener('click', () => { paused = !paused; });
  selMode.addEventListener('change', () => { mode = selMode.value; });
  selAI.addEventListener('change', () => { aiLevel = selAI.value; });

  padSpeedSlider.addEventListener('input', () => {
    padSpeedScale = Number(padSpeedSlider.value) / 100;
    padSpeedVal.textContent = Math.round(padSpeedScale * 100) + '%';
  });

  ballSpeedSlider.addEventListener('input', () => {
    ballSpeedScale = Number(ballSpeedSlider.value) / 100;
    ballSpeedVal.textContent = Math.round(ballSpeedScale * 100) + '%';
  });

  function movePaddle(p, dtF, scale){
    const accel = PAD_ACCEL_BASE * padSpeedScale * (scale ?? 1);
    const maxV = PAD_MAX_V_BASE * padSpeedScale * (scale ?? 1);
    if (p.up) p.vy -= accel * dtF;
    if (p.down) p.vy += accel * dtF;
    p.vy *= Math.pow(PAD_FRICTION, dtF);
    p.vy = clamp(p.vy, -maxV, maxV);
    p.y += p.vy * dtF;
  }

  function predictY(){
    if (ball.dx <= 0) return canvas.height/2;
    let tx = canvas.width - (PADDLE_MARGIN + PADDLE_W) - ball.r;
    let time = (tx - ball.x) / ball.dx;
    if (time <= 0) return canvas.height/2;
    let y = ball.y + ball.dy * time;
    const H = canvas.height;
    while (y < ball.r || y > H - ball.r){
      if (y < ball.r) y = ball.r + (ball.r - y);
      else if (y > H - ball.r) y = (H - ball.r) - (y - (H - ball.r));
    }
    return y;
  }

  function aiMove(dtF){
    if (mode !== 'solo' || awaitingServe) return;
    const targetY = predictY();
    const center = right.y + PADDLE_H/2;
    let speedScale = 1.0, noise = 0, dead = 6;
    if (aiLevel==='easy'){ speedScale = 0.8; noise = 14; dead = 14; }
    else if (aiLevel==='normal'){ speedScale = 1.3; noise = 8; dead = 10; }
    else { speedScale = 1.8; noise = 4; dead = 6; }
    const err = (Math.random()*2-1)*noise;
    right.up = right.down = false;
    const aim = targetY + err;
    if (aim < center - dead) right.up = true; else if (aim > center + dead) right.down = true;
    movePaddle(right, dtF, speedScale);
    right.y = clamp(right.y, 0, canvas.height - PADDLE_H);
  }

  function step(dtF){
    if (paused || over) return;

    movePaddle(left, dtF, 1);
    if (mode==='duo') movePaddle(right, dtF, 1);
    left.y = clamp(left.y, 0, canvas.height - PADDLE_H);
    right.y = clamp(right.y, 0, canvas.height - PADDLE_H);

    aiMove(dtF);

    if (awaitingServe) return;

    ball.x += ball.dx; ball.y += ball.dy;

    if (ball.y - ball.r < 0){ ball.y = ball.r; ball.dy = Math.abs(ball.dy); }
    if (ball.y + ball.r > canvas.height){ ball.y = canvas.height - ball.r; ball.dy = -Math.abs(ball.dy); }

    const lX = PADDLE_MARGIN + PADDLE_W, rX = canvas.width - PADDLE_MARGIN - PADDLE_W;

    if (ball.x - ball.r <= lX && ball.x - ball.r >= PADDLE_MARGIN && ball.y >= left.y && ball.y <= left.y + PADDLE_H && ball.dx < 0){
      const hit = (ball.y - (left.y + PADDLE_H/2)) / (PADDLE_H/2);
      const speed = Math.min(BALL_MAX_SPEED_BASE*ballSpeedScale, Math.hypot(ball.dx, ball.dy) * 1.02);
      const angle = hit * (Math.PI/3);
      ball.dx = Math.abs(speed * Math.cos(angle));
      ball.dy = speed * Math.sin(angle);
    }

    if (ball.x + ball.r >= rX && ball.x + ball.r <= canvas.width - PADDLE_MARGIN && ball.y >= right.y && ball.y <= right.y + PADDLE_H && ball.dx > 0){
      const hit = (ball.y - (right.y + PADDLE_H/2)) / (PADDLE_H/2);
      const speed = Math.min(BALL_MAX_SPEED_BASE*ballSpeedScale, Math.hypot(ball.dx, ball.dy) * 1.02);
      const angle = hit * (Math.PI/3);
      ball.dx = -Math.abs(speed * Math.cos(angle));
      ball.dy = speed * Math.sin(angle);
    }

    if (ball.x < 0){ sR++; updateUI(); resetPositions(); }
    if (ball.x > canvas.width){ sL++; updateUI(); resetPositions(); }

    const target = Number(winScore.value || 7);
    if (sL >= target || sR >= target){ over = true; paused = true; }
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.strokeStyle = COLORS.mid; ctx.lineWidth = 2; ctx.setLineDash([8,10]);
    ctx.beginPath(); ctx.moveTo(canvas.width/2, 10); ctx.lineTo(canvas.width/2, canvas.height-10); ctx.stroke(); ctx.setLineDash([]);

    ctx.fillStyle = COLORS.paddle;
    ctx.fillRect(PADDLE_MARGIN, Math.round(left.y), PADDLE_W, PADDLE_H);
    ctx.fillRect(canvas.width - PADDLE_MARGIN - PADDLE_W, Math.round(right.y), PADDLE_W, PADDLE_H);

    ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.fillStyle = COLORS.ball; ctx.fill(); ctx.closePath();

    if (awaitingServe){
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(canvas.width/2-200, canvas.height/2-36, 400, 40);
      ctx.fillStyle = '#cfe0ff'; ctx.font = 'bold 18px system-ui'; ctx.textAlign = 'center';
      ctx.fillText('Press Space or Click to Serve', canvas.width/2, canvas.height/2 - 10);
    }

    if (paused){
      ctx.fillStyle = 'rgba(0,0,0,0.45)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#cfe0ff'; ctx.font = 'bold 28px system-ui'; ctx.textAlign = 'center';
      ctx.fillText(over ? 'Match Over' : 'Paused', canvas.width/2, canvas.height/2 - 10);
      if (over) ctx.fillText('Press R to restart', canvas.width/2, canvas.height/2 + 24);
    }
  }

  let last=0; function loop(ts){ if(!last) last = ts; const dt = ts - last; last = ts; const dtF = Math.min(2, dt / (1000/60)); if(!paused) step(dtF); draw(); requestAnimationFrame(loop); }

  function log(t, ok){ const el = document.createElement('div'); el.innerHTML = (ok? '✅ <span class="pass">PASS</span> ' : '❌ <span class="fail">FAIL</span> ') + t; diag?.appendChild(el); (ok?console.log:console.error)(t); }
  function clearDiag(){ if (diag) diag.innerHTML=''; }
  function runTests(){
    clearDiag();
    start();
    log('Paddles initialized on screen', left.y>=0 && left.y<=canvas.height-PADDLE_H && right.y>=0 && right.y<=canvas.height-PADDLE_H);
    serve(1); const s1=Math.hypot(ball.dx,ball.dy); log('Serve speed respects slider', Math.abs(s1 - BALL_BASE_SPEED*ballSpeedScale) < 0.25);
    ball.y = ball.r-1; ball.dy = -Math.abs(ball.dy); step(1); log('Top wall bounces down', ball.dy>0);
    ball.x = -10; step(1); log('Right score increments when ball exits left', Number(scoreR.textContent)>0);
    resetPositions(); const y0 = right.y; aiMove(1); log('AI idle awaiting serve', right.y===y0);
  }
  btnTests?.addEventListener('click', runTests);

  if (padSpeedSlider) { padSpeedSlider.value = '200'; padSpeedVal.textContent = '200%'; padSpeedScale = 2.0; }
  if (ballSpeedSlider) { ballSpeedSlider.value = '100'; ballSpeedVal.textContent = '100%'; ballSpeedScale = 1.0; }

  start();
  runTests(); if (diagBox && diag.textContent.includes('FAIL')) diagBox.open = true;
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
